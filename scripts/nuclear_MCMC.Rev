##################################
## Nuclear DNA data only model  ##
##    EEOB 563 final project    ##
#   Bruno do Rosario Petrucci   ##
##################################

###
# set up basic objects for the analysis

# read nuclear DNA data
nuclear <- readDiscreteCharacterData("data/nuclear.nex")

# some quantities that we may like to use later
n_taxa <- nuclear.ntaxa()
n_branches <- 2 * n_taxa - 3
taxa <- nuclear.taxa()

# set up moves and monitor vectors
moves = VectorMoves()
monitors = VectorMonitors()

###
# set up tree model

# topology
top ~ dnUniformTopology(taxa, outgroup = clade("Urocyon_cinereoargenteus"))

moves.append( mvNNI(top, weight = n_taxa) )
moves.append( mvSPR(top, weight = n_taxa / 2) )

# branch lengths
for (i in 1:n_branches) {
  br_lens[i] ~ dnExponential(10.0)
  moves.append( mvScale(br_lens[i], lambda = 0.01, weight = 1) )
  moves.append( mvScale(br_lens[i], lambda = 0.1, weight = 1) )
  moves.append( mvScale(br_lens[i], lambda = 1, weight = 1) )
}

# phylogeny
phy := treeAssembly(top, br_lens)

### 
# set up substitution model

# pi - base frequencies
pi ~ dnDirichlet( v(1, 1, 1, 1) )
moves.append( mvBetaSimplex(pi, weight = 5) )
moves.append( mvDirichletSimplex(pi, weight = 2.5) )

# exchangeability rates for GTR transversions
er_trans ~ dnDirichlet( v(1, 1, 1, 1) )
moves.append( mvBetaSimplex(er_trans, weight = 5) )
moves.append( mvDirichletSimplex(er_trans, weight = 2.5) )

# exchangeability rates - need to do this since the data set is
# transversions only
er := Simplex(v(er_trans[1], 0, er_trans[2], er_trans[3], 0, er_trans[4]))

Q := fnGTR(er, pi)

# finally define the CTMC model
seq ~ dnPhyloCTMC(tree = phy, Q = Q, type = "DNA")
seq.clamp(nuclear)

# make the model object
mymodel = model(phy)

###
# set up monitors and run

# monitors
monitors.append( mnModel(filename = "output_nuclear/nuclear.log", printgen = 10, separator = TAB) )
monitors.append( mnFile(filename = "output_nuclear/nuclear.trees", printgen = 10, phy) )
monitors.append( mnScreen(printgen = 1000) )
# to the screen we will just worry about the indicators

# run MCMC
mymcmc = mcmc(mymodel, moves, monitors, nruns = 2, combine = "mixed")
mymcmc.run(generations = 50000, tuningInterval = 200, checkpointInterval = 100, checkpointFile = "output_nuclear/nuclear.state")
